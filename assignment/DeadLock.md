
#Deadlock(死锁)
-------------------
##死锁是什么？
------------------  
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的  
一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时  
称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程  
称为死锁进程。  

-------------------------------------------------------------------
##代码详解
-------------
![代码1](http://a3.qpic.cn/psb?/V10xhQuy3m7suY/vpdxa5yqA7ti2K6kGYF98yDaxppEPweq.adqHnqrDI0!/b/dHwBAAAAAAAA&bo=1wE0AQAAAAADAMY!&rf=viewer_4)  

**关键字synchronized:**
>当它用来修饰一个方法或者一个代码块时，能够  
保证在同一个时刻最多只有一个线程执行该段代码；    

>当一个线程访问object的一个synchronized同步代  
码块或者同步方法时，其他线程对object中所有其  
它synchronized同步代码块或同步方法的访问将被  
阻塞。  

------------------------------------------------------------------
![代码2](http://a2.qpic.cn/psb?/V10xhQuy3m7suY/er6kDliIm2zQvQNubRZbKhfjwvnANC5JHfI4fia4bOc!/b/dHIBAAAAAAAA&bo=0AFWAQAAAAADAKM!&rf=viewer_4)  

* 实例化函数a和函数b；
* 创建Deadlock线程；后创建t线程；
* t.start()后，线程t被插入到调度队列中，当  
调度到他的时候，就跑到run()，执行其中代码。  

----------------------------------------------------
##结果分析
-------------  
![结果图1](http://a1.qpic.cn/psb?/V10xhQuy3m7suY/1VBARNnwMElHgt2Y8e6eORCQdBp4eDtZDFjglh*1r68!/b/dAsBAAAAAAAA&bo=vgFjAQAAAAADB*8!&rf=viewer_4)  
  
![效果图2](http://a1.qpic.cn/psb?/V10xhQuy3m7suY/CVoIjS8AdthLxY9GS*rMIfuDdRGQv3dwT2oTEd9v0Yg!/b/dHcBAAAAAAAA&bo=xQF3AQAAAAADAJc!&rf=viewer_4)    
**这里我将count的值改为5000，它开始运行到产生死锁的循环次数不一**    

----------------------------------------------------------------------------------  
##产生死锁的四个必要条件
------------------------------   
 
**互斥条件：一个资源每次只能被一个进程使用**    
**请求与保持条件：一个进程因为请求资源而阻塞的同时，对已有的资源保持不放**  
**不剥夺条件：进程已获得的资源，在未被完全使用之前，不能剥夺**  
**循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。**  

--------------------------------------------------------------------------------------------
##这次实验会产生死锁的原因
---------------------------------
A类函数和B类函数会互相申请对方的资源，但是在两个进程Deadlock和t之间，  
每次先run函数b，在回头运行函数a，这个过程中a要申请b的资源，还要等待  
b释放已经得到的资源；当count值也就是延时不够长的情况下，就会导致死锁。
